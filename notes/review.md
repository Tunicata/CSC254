# Ch1 Introduction

Why are there so many programming languages? 

- Evolution -- We've learned better ways of doing things over time
- Orientation toward special purposes/hardware
- Personal preferences
- Socio-economic factors -- proprietary interests, commercial advantages

What makes a language successful? 

- Easy to learn (BASIC, LOGO, Scheme, Python)
- Easy to express things -- Easy to use once fluent -- "Powerful" (C++, Haskell, Common Lisp, Perl, APL)
- Easy to implement (BASIC, Forth)
- Possible to compile to very good (fast/small) code (C, Fortran)
- Exceptionally good at something important (PHP, Ruby on Rails, R)
- Backing of a powerful sponsor (COBOL, Ada, Visual Basic, C#, Swift)
- Wide dissemination at minimal cost (Pascal, Java, Python, Ruby)

Why do we have programming languages? 

- Abstraction of virtual machine -- Way of specifying what you want the hardware to do without getting down into the bits (from implementer's point of view)
- Way of thinking -- Way of expressing algorithms (from user's point of view)



Imperative

- **von Neumann**: Fortan, Ada, Pascal, Basic, C, ...
- **object-orientated**: Smalltalk, Eiffel, C++, Java, C#, Swift, Ocaml, ...
- **scripting**: perl, Python, PHP, Ruby, Javascript, Matlab, R, ...

Declarative

- **functional**: Scheme/Lisp, ML/Ocaml/Haskell/F#
- **logic, constraint-based**: Prolog, OPS5, spreadsheet, XSLT



# Ch2 Syntax





# Ch3 Names, Scopes and Bindings





# Ch4 Semantic

